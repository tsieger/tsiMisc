plot3dProj<-structure(
function # Visualize multidimensional data in 3D and/or multiple 2D projections.
##description<<
## TODO
(x, ##<< a data frame or matrix to visualize. Instances in rows,
## features in columns. It must have at least 3 columns (dimensions).
col =  NULL, ##<< the color of individual instances
## color of individual instances, recycled if necessary
cls = NULL, ##<< class membership of individual instances. This serves
## the only purpose of alternative color specification: if
## 'col' is NULL ...
size = 3, ##<< size of points
alpha = 1, ##<< alpha of points
main = NULL, ##<< title of \code{x}
x2 = NULL, ##<< another data frame or matrix to visualize.
col2 =  NULL, ##<< the color of data in \code{x2}
cls2 = NULL, ##<< class membership of data in \code{x2}
size2 = 3, ##<< size of points in \code{x2}
alpha2 = 1, ##<< alpha of points in \code{x2}
main2 = NULL, ##<< title of \code{x2}
x3 = NULL, ##<< another data frame or matrix to visualize.
col3 =  NULL, ##<< the color of data in \code{x3}
cls3 = NULL, ##<< class membership of data in \code{x3}
size3 = 3, ##<< size of points in \code{x3}
alpha3 = 1, ##<< alpha of points in \code{x3}
main3 = NULL, ##<< title of \code{x3}
palette = c('black','red','green','blue'), ##<< color palette to be
## used for individual classes specified in \code{cls}, see the
## \code{col} argument
scale = TRUE, ##<< if TRUE, data get scaled to the range of '[-1, 1]'
## in all dimensions
tx = function(y,center=TRUE) y-center*matrix(colMeans(x),nrow=nrow(y),ncol=ncol(x),byrow=TRUE), ##<< Transform
## function used to transform data from the k-dimensional space of 'x'
## into 3D space to visualize. The function must accept two arguments:
## a data matrix to transform, and a logical called \code{center}
## specifying whether to center the data prior the transform. The
## function must return a 3-column transformed version of the input
## data matrix.
dimToShow = 1:ncol(x), ##<< a numeric or character vector of dimensions
## of \code{x} to plot. If numeric, it indexes the dimensions to show.
## If character, it lists  the names of dimensions to show.
## The default it to plot all dimensions. \code{dimToShow} takes
## precedence over \code{k}, another way to specify the dimensions to
## show.
k = NULL, ##<< if \code{tx} is one of \code{\link{txPca}} or
## \code{\link{txSpa}}, \code{k} can specify the number of (most
## "significant") dimensions to plot. The default is the number of
## dimensions of \code{x}, but smaller values are recommended for
## high-dimensional data in order to speed up plotting. Internally, the
## \code{k} dimensions selected to be shown are those which contribute
## the most to the top \code{k} components (principal or supervised
## principal components) of the data. To determine this contribution,
## the code calls the \code{varExplained} stored as a name member of a
## list attached to the \code{tx} argument as the \code{params}
## attribute. This function takes \code{k}, the number of top
## components, and returns the contribution of individual dimensions to
## these components.
type = 'tawm,sw', ##<< a character string defining the type of plots to
## produce. There general syntax is \code{<row>;<row>;...;<row>},
## where each \code{<row>} stands for \code{<plot>,<plot>,...,<plot>},
## and each \code{plot} is a concatenation of one or more plot types to
## be combined in the specific plot. The plot types are:
## \itemize{
##   \item \code{t} - \strong{t}hree-dimensional scatter plot
##   \item \code{s} - parallelepipedon having 2D \strong{s}catter plots
##             on its faces
##   \item \code{w} - \strong{w}ire frame defining the feature space
##             (the wireframe collides with the edges of the 
##             parallelepipedon plotted by \code{s})
##   \item \code{a} - \strong{a}xes of the feature space
##   \item \code{m} - \strong{m}ain (title) of data
##  }
## Each of \code{t}, \code{s}, and \code{m} can be followed by a number
## referring to a specific data (i.e. \code{x}, \code{x2}, or
## \code{x3}). By default, when no number follows the plot type, the
## \code{x} is assumed.
## For example: \code{tawm,sw} defines two subscenes to be plotted in
## one row next to each other. The first plot type \code{tawm} defines
## a \strong{t}hree dimensional scatter plot annotated with
## \strong{a}xes and enriched with a \strong{w}ire frame and the
## \strong{m}ain (title).
## The second plot type \code{sw} defines a parallelepipedon having
## \strong{s}catter plots on its faces, and enriched with a
## \strong{w}ire frame.
widths = 1, ##<< relative widths of columns in a multi-subscene scene,
## see \code{\link[rgl]{layout3d}}
heights = 1, ##<< relative heights of rows in a multi-subscene scene,
## see \code{\link[rgl]{layout3d}}
devices = rgl.cur(), ##<< a list of devices to plot at, defaulting to
## the current active device, if any. If \code{devices} is NULL, empty,
## contains invalid devices, or does not hold enough devices to plot
## all the scenes requested by the \code{type} argument, new scene(s)
## will be created for such scenes.
col.axes = 'gray', ##<< color of axes in the 3D plot
axesExpansion = 1.1, ##<<
annotate=FALSE,
debug = FALSE ##<< if TRUE, debugs will be printed. If numeric of value
## greater than 1, verbose debugs will be produced.
) {
  #library(rgl) # open3d,mfrow3d,spheres3d,lines3d,text3d
  #library(e1071) # bincombinations
  #library(geometry) # convhulln
  #library(tsiMisc) # vectorprod

  if (!is.matrix(x)) x<-as.matrix(x)
  if (!is.null(cls)) cls<-as.factor(cls)

  # check the \code{tx} argument
  if (is.null(tx)) {
    stop('need an \'tx\' argument')
  }
  if (length(formals(tx))!=2 || names(formals(tx))[2]!='center') {
    stop('\'tx\' must take two arguments, and the second must be named \'center\'')
  }
  tmp<-tx(x[1,,drop=FALSE],center=TRUE)
  if (!inherits(tmp,'matrix')) {
    stop('invalid \'tx\' argument: it does not produce a matrix ',
      '(maybe you forgot to add \'drop=FALSE\' when indexing your matrix')
  }

  # dimensionality of \code{x}
  k0<-ncol(x)
  if (debug) .pn(k0)
  if (debug) .pn(k)

  if (k0<3) {
    stop('we need at least 3D data')
  }
  if (ncol(tx(x[1,,drop=FALSE],center=TRUE))!=3) {
    stop('\'tx\' must result in 3D data')
  }

  if (!is.null(dimToShow)) {
    if (!is.null(k)) {
      stop('can\'t specify both the \'dimToShow\' and \'k\' arguments')
    }
    if (debug) {
      cat('guessing which dimensions to show from \'dimToShow\' argument\n')
      .pn(dimToShow)
    }
    if (is.numeric(dimToShow)) {
      if (!all(dimToShow %in% 1:k0) || anyDuplicated(dimToShow)) {
        stop('invalid \'dimToShow\' argument, expected unique numbers in the range of 1 to',k0)
      }
      dimVisible<-(1:k0)%in%dimToShow
    } else {
      dimVisible<-colnames(x)%in%dimToShow
    }
    k<-sum(dimVisible)
    if (k<3) {
      stop('\'dimToShow\' argument selects ',sum(dimVisible),
        ' dimension(s), and we need at least 3 for a 3D plot')
    }
  } else if (!is.null(k) && k<k0) {
    if (k<3) {
      stop('invalid \'k\' argument, must be >= 3')
    }
    # user requested to draw fewer than \code{k0} dimensions
    # determine which dimensions to omit
    if (!is.null(attr(tx,'params')) &&
      !is.null(attr(tx,'params')$varExplained) &&
      is.function(attr(tx,'params')$varExplained)) {
      varExpl<-attr(tx,'params')$varExplained(k)
      if (debug) {
        cat('deviance in first k dimensions:\n')
        .pn(varExpl)
      }
      dimVisible<-varExpl>=sort(varExpl,decreasing=TRUE)[k]
    } else {
      stop('can\'t determine which dimensions to show: ',
        '\'tx\' does not contain \'varExplained\' function')
    }
  } else {
    k<-k0
    dimVisible<-rep(TRUE,k0)
  }
  if (debug) .pn(dimVisible)
  dimVisibleIdx<-which(dimVisible)
  if (debug) .pn(dimVisibleIdx)

  if (is.null(col) || length(col)==0) {
    if (!is.null(cls) && !is.null(palette)) {
      col<-palette[cls]
    } else {
      col<-'black'
    }
  }
  if (!is.null(x2)) {
    if (is.null(col2) || length(col2)==0) {
      if (!is.null(cls2) && !is.null(palette)) {
        col2<-palette[cls2]
      } else {
        col2<-'black'
      }
    }
  }
  if (!is.null(x3)) {
    if (is.null(col3) || length(col3)==0) {
      if (!is.null(cls3) && !is.null(palette)) {
        col3<-palette[cls3]
      } else {
        col3<-'black'
      }
    }
  }

  if (scale) {
    x<-scaleToUnit(x,-1,1)
    if (!is.null(x2)) {
      scalingTx<-attr(x,'scaleToUnit:tx')
      stopifnot(scalingTx!=NULL)
      x2<-scalingTx(x2)
    }
    if (!is.null(x3)) {
      scalingTx<-attr(x,'scaleToUnit:tx')
      stopifnot(scalingTx!=NULL)
      x3<-scalingTx(x3)
    }
  }

  doPlotWireFrame<-stringr::str_detect(type,'w')
  doPlotScatters<-stringr::str_detect(type,'s')

  buildWireFrame<-function() {
    wireFrame<-matrix(NA,nrow=3*k*2^(k-1),ncol=3)
    bs<-e1071::bincombinations(k-1)
    cnt<-0
    for (i in 1:k) {      # 'i' iterates over 'dimVisibleIdx'
      b1<-rep(.5,k0) # .5 for invisible dimensions
      b2<-b1
      b1[dimVisibleIdx[i]]<-0
      b2[dimVisibleIdx[i]]<-1
      for (bi in 1:nrow(bs)) {
        b1[dimVisibleIdx[-i]]<-b2[dimVisibleIdx[-i]]<-bs[bi,]
        if (signatureInConvhull[signature(b1)]&&signatureInConvhull[signature(b2)]) {
          v1<--1+2*b1
          v2<--1+2*b2
          tmp<-rbind(v1,v2)
          colnames(tmp)<-colnames(x)
          wireFrame[cnt+1,]<-tx(tmp[1,,drop=FALSE],center=FALSE)
          wireFrame[cnt+2,]<-tx(tmp[2,,drop=FALSE],center=FALSE)
          # reserve lines of NA's
          cnt<-cnt+3
          #lines3d(rbind(tx(rbind(v1)),tx(v2)),color=c('gray'))
        }
        #lines3d(rbind(tx(v1),tx(rbind(v2))),color=c('gray','blue')[(in.convhull(v1)&in.convhull(v2))+1])
      }
    }
    wireFrame<-wireFrame[1:cnt,]
    return(wireFrame)
  }

  if (doPlotScatters || doPlotWireFrame) {
    # compute coordinates of all vertices of the individual axes in the untransformed space
    bs0<-e1071::bincombinations(k)
    bs0<-bs0[,ncol(bs0):1]
    # make sure we got what we expected,
    # each pair of vertices must differ just in the first coordinate
    stopifnot(bs0[1,-1]==bs0[2,-1])
    # supplement dimensions to show with zeros for hidden dimensions
    # (insert zero columns at invisible dimensions)
    bs<-matrix(.5,nrow(bs0),k0)
    i<-1
    for (i0 in 1:k0) {
      if (dimVisible[i0]) {
        bs[,i0]<-bs0[,i]
        i<-i+1
      }
    }
    # Now we consider a 0/1 vector as a binary number, and
    # this way characterize the vector by a single number.
    # (Note we convert .5 (standing for hidden dims) to 0 when
    # computing the signature.)
    signature<-function(x) 1+crossprod(x==1,2^((length(x)-1):0))
    bSignatures<-apply(bs,1,signature)
    vs<--1+2*bs
    colnames(vs)<-colnames(x)
    if (debug>1) .pn(vs)
    # find convex hull - only points on the convex hull will be visible
    idx.convhull<-unique(as.numeric(geometry::convhulln(tx(rbind(vs),center=FALSE))))
    #sort(idx.convhull)
    idxInConvhull<-1:nrow(vs)%in%idx.convhull
    signatureInConvhull<-rep(FALSE,2^k0)
    signatureInConvhull[bSignatures[idxInConvhull]]<-TRUE
    if (debug>1) .pn(signatureInConvhull)
  }
  if (doPlotWireFrame) {
    wf<-buildWireFrame()
    if (debug>1) .pn(wf)
  }


  ###
  ## plotting functions
  plotAxes<-function() {
    if (!is.null(colnames(x))) {
      v0<-rep(0,k0)
      axes.radius<-c(.01,.01,.03,0)
      for (i in 1:k) {
        v1<-v2<-v3<-v4<-rep(0,k0)
        v1[dimVisibleIdx[i]]<-.95
        v2[dimVisibleIdx[i]]<-.95
        v3[dimVisibleIdx[i]]<-1
        v4[dimVisibleIdx[i]]<-1.1
        tmp<-rbind(v0,v1,v2,v3,v4)
        colnames(tmp)<-colnames(x)
        shade3d(cylinder3d(tx(axesExpansion*tmp[1:4,],center=FALSE),
          radius=axes.radius,closed=-2),col=col.axes)
          #,emission=col.axes,specular=col.axes,alpha=1,shininess=0)
        text3d(tx(axesExpansion*tmp[5,,drop=FALSE],center=FALSE),
          texts=colnames(x)[dimVisibleIdx[i]],col=col.axes)
          #,emission=col.axes,specular=col.axes,alpha=1,shinness=0)
      }
    }
  }

  # plot wire frame
  plotWireFrame<-function(annotate=FALSE) {
    lines3d(wf,color='lightgray',alpha=.5)
    #lines3d(wf,color='lightgray',emission='lightgray',
    #specular='lightgray',ambient='lightgray',alpha=.5,shiness=50)

    if (annotate) {
      # mark point (-1,-1,-1,...,-1)
      v<-rep(.5,k0)
      v[dimVisibleIdx]<--1
      tmp<-rbind(v)
      colnames(tmp)<-colnames(x)
      points3d(tx(tmp,center=FALSE),color='black',size=10)
      # mark axes pointing away from (-1,-1,-1,...,-1,0,0,0)
      for (i in 1:k) {
        v<-rep(.5,k0)
        v[dimVisibleIdx]<--1
        v[dimVisibleIdx[i]]<-1
        tmp<-rbind(v)
        colnames(tmp)<-colnames(x)
        text3d(tx(tmp,center=FALSE),texts=i)
      }
    }
  }

  # plot 3D scatter plot of observations
  plot3dScatter<-function(x,size,col,alpha) {
    #spheres3d(tx(x),radius=radius,color=col,alpha=alpha)
    if (length(unique(size))==1) {
      points3d(tx(x,!scale),size=size[1],color=col,alpha=alpha)
    } else {
      tmp.size<-rep(size,length=nrow(x))
      tmp.col<-rep(col,length=nrow(x))
      tmp.alpha<-rep(alpha,length=nrow(x))
      for (s in unique(size)) {
        points3d(tx(x[tmp.size==s,,drop=FALSE],!scale),size=s,
          color=tmp.col[tmp.size==s],alpha=tmp.alpha[tmp.size==s])
      }
    }
  }

  # plot a projection of k-dimensional parallelepipedon having scatter
  # plots on its faces
  plotScatters<-function(x,size,col,alpha) {
    textureFileName<-tempfile('texture',fileext='.png')
    for (i1 in 1:(nrow(vs)-2)) {
      if (i1 %in% idx.convhull) {
        v1<-vs[i1,]
        for (i2 in (i1+1):(nrow(vs)-1)) {
          v2<-vs[i2,]
          if (i2 %in% idx.convhull && sum(v1!=v2)==1) {
            for (i3 in (i2+1):nrow(vs)) {
              v3<-vs[i3,]
              if (i3 %in% idx.convhull && sum(v1!=v2)==1 &&
                sum(v1!=v3)==1 && sum(v2!=v3)==2) {
                #cat(sprintf('%d %d %d\n',i1,i2,i3))
                v4<-v2+v3-v1
                i4<-which(apply(vs,1,function(x)all(v4==x)))
                if (!i4 %in% idx.convhull) next
                # order the vertices such that the face points towards inside
                tmp<-rbind(v1,v2,v4)
                colnames(tmp)<-colnames(x)
                tmp<-tx(tmp,center=FALSE)
                if (tcrossprod(vectorprod(
                  tmp[1,,drop=FALSE],
                  tmp[2,,drop=FALSE]),
                  tmp[3,,drop=FALSE])<0) {
                  w1<-v1
                  w2<-v2
                  w4<-v4
                  w3<-v3
                } else {
                  w1<-v1
                  w2<-v3
                  w4<-v4
                  w3<-v2
                }
                # create a scatter plot texture 
                png(textureFileName)
                opar<-par(mar=c(6,5,4,2)+.1, ask=FALSE)
                idx1<-which(w2-w1!=0)
                idx2<-which(w3-w1!=0)
                plot(x[,c(idx1,idx2)],pch=19,frame=F,col=col,cex.lab=3)
                #,xlim=c(-1,1),ylim=c(-1,1))
                #text(0,.5,paste(idx1,idx2),cex=8)
                #text(0,-.5,paste(crossprod(vectorprod(v1,v2),v4)<0,
                #  paste(w2-w1,collapse=' '),paste(w3-w1,collapse=' '),sep=','),cex=3)
                par(opar)
                dev.off()
                # plot the texture
                #rgl.quads(tx(rbind(w1,w2,w4,w3)),texture=textureFileName,alpha=.5,
                #  texcoord=rbind(c(0,0),c(1,0),c(1,1),c(0,1)),lit=FALSE,front='fill',back='cull')
                tmp<-rbind(w1,w2,w4,w3)
                colnames(tmp)<-colnames(x)
                rgl.quads(tx(tmp,center=FALSE),
                  texture=textureFileName,
                  alpha=1,texcoords=rbind(c(0,0),c(1,0),c(1,1),c(0,1)),
                  lit=TRUE,shininess=100,front='fill',back='cull',
                  ambient=gray(.5),specular='black')
              }
            }
          }
        }
      }
    }
    #unlink(textureFileName)
  }

  plotTitle<-function() {
    decorate3d(main=main,box=FALSE,axes=FALSE)
  }

  if (debug) .pn(devices)
  scenes<-c()
  # split to scenes
  sceneTypes<-str_split(type,'\\|')[[1]]
  for (i in seq(along=sceneTypes)) {
    sceneType<-sceneTypes[i]

    if (debug) cat(sprintf('plotting scene "%s"\n',sceneType));
    if (length(devices)>=i && devices[i]%in%rgl.dev.list()) {
      if (debug) cat(sprintf('reusing device %d for scene %d\n',devices[i],i));
      rgl.set(devices[i])#,silent=TRUE
      rgl.clear(type='shapes')
      rgl.clear(type='userviewpoint')
    } else {
      if (debug) cat('opening a new device\n')
      open3d()
    }
    scenes<-c(scenes,rgl.cur())
    #}
    # split to rows of subscenes
    subsceneRowTypes<-str_split(sceneType,';')[[1]]
    # how many columns?
    maxRowSize<-0
    for (subsceneRowType in subsceneRowTypes) {
      subsceneTypes<-str_split(subsceneRowType,',')[[1]]
      maxRowSize<-max(maxRowSize,length(subsceneTypes))
    }
    if (debug) {
      cat(sprintf('opening %d x %d subscenes\n',
        length(subsceneRowTypes),maxRowSize))
    }
    if (debug) {
      .pn(length(subsceneRowTypes))
      .pn(maxRowSize)
    }
    m<-matrix(1:(maxRowSize*length(subsceneRowTypes)),
      length(subsceneRowTypes),maxRowSize,byrow=TRUE)
    widths<-rep(widths[1:min(length(widths),maxRowSize)],
      length.out=maxRowSize)
    heights<-rep(heights[1:min(length(heights),length(subsceneRowTypes))],
      length.out=length(subsceneRowTypes))
    layout3d(mat=m,widths=widths,heights=heights,sharedMouse=TRUE)
    if (debug) {
      .pn(m)
      .pn(widths)
      .pn(heights)
    }
    firstSubscene<-TRUE
    for (subsceneRowType in subsceneRowTypes) {
      if (debug) cat(sprintf(' plotting subscene row "%s"\n',subsceneRowType));
      subsceneTypes<-str_split(subsceneRowType,',')[[1]]
      for (subsceneType in subsceneTypes) {
        if (debug) cat(sprintf('  plotting subscene "%s"\n',subsceneType));
        if (firstSubscene) {
          firstSubscene<-FALSE
        } else {
          if (debug>1) cat('  calling next3d()\n')
          next3d(reuse=FALSE)
        }
        plotTypes<-str_split(subsceneType,'')[[1]]
        plotTypeIdx<-1
        while (plotTypeIdx<=str_length(subsceneType)) {
          plotType<-plotTypes[plotTypeIdx]
          plotTypeIdx<-plotTypeIdx+1
          # is there a numer following the plotType?
          if (plotTypeIdx<=str_length(subsceneType) &&
            regexpr('[1-3]',plotTypes[plotTypeIdx])!=-1) {
              xi<-as.integer(plotTypes[plotTypeIdx])
              plotTypeIdx<-plotTypeIdx+1
              switch(xi,
                , # no need to test 'x', as it must always be present
                if (is.null(x2)) {
                  stop(paste0('unspecified \'x2\' data referred to from subscene \'',
                    subsceneType,'\''))
                },
                if (is.null(x3)) {
                  stop(paste0('unspecified \'x3\' data referred to from subscene \'',
                    subsceneType,'\''))
                },
                stop(paste0('invalid data referred to from plotTypes \'',
                    plotTypes,'\''))
              )
          } else {
            xi<-1
          }
          if (debug) cat(sprintf('    seen plotType "%s"\n',plotType));
          if (length(plotType)>0) {
            switch(plotType,
              'a'=plotAxes(),
              'w'=plotWireFrame(),
              't'=switch(xi,
                plot3dScatter(x,size,col,alpha),
                plot3dScatter(x2,size2,col2,alpha2),
                plot3dScatter(x3,size3,col3,alpha3)),
              's'=switch(xi,
                plotScatters(x,size,col,alpha),
                plotScatters(x2,size2,col2,alpha2),
                plotScatters(x3,size3,col3,alpha3)),
              'm'=switch(xi,
                plotTitle(main),
                plotTitle(main2),
                plotTitle(main3)),
              'otherwise'=stop('unknown type "',plotType,'"'))
          }
        }
      }
    }
  }
  rglSetMouseCbTrackball(scenes)

  return(scenes)
  ### a list of rgl device IDs holding the scenes plotted

},ex=function() {
  if (interactive() && require(rgl)) {
    plot3dProj(iris[,1:3], cls=iris$Species)
    plot3dProj(x = iris[, 1:3], cls = iris$Species,
      main = 'Setosa, Versicolor and Virginica',
      x2 = iris[iris$Species != 'virginica', 1:3],
      cls2 = iris$Species[iris$Species != 'virginica'],
      main2 = 'Setosa and Versicolor',
      ty='sw,tw,t2,s2;,a',heights=c(2,1),debug=1)
  }

# TODO: unify/propagate scaling done in plot3dProj here ?!
#  p <- prcomp(iris[, 1:4], center = TRUE, scale = TRUE)
#  tx <- function (y,center=TRUE) {
#    if(center) y<-y-matrix(colMeans(iris[, 1:4]),nrow=nrow(y),ncol=4,byrow=TRUE)
#    y<-t(t(p$rotation[,1:3])%*%t(y))
#    return (y)
#  }
#  plot3dProj(iris[,1:4], tx=tx, cls=iris$Species)

})
